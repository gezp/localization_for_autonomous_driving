// Copyright 2023 Gezp (https://github.com/gezp).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "localization_common/sensor_data/velocity_data.hpp"

namespace localization_common
{
void VelocityData::transform_coordinate(Eigen::Matrix4f transform_matrix)
{
  Eigen::Matrix3f R = transform_matrix.block<3, 3>(0, 0);
  Eigen::Vector3f t = transform_matrix.block<3, 1>(0, 3);

  // get angular & linear velocities in IMU frame:
  Eigen::Vector3f w = angular_velocity;
  Eigen::Vector3f v = linear_velocity;

  // a. first, add velocity component generated by rotation:
  Eigen::Vector3f delta_v;
  delta_v(0) = w(1) * t(2) - w(2) * t(1);
  delta_v(1) = w(2) * t(0) - w(0) * t(2);
  delta_v(2) = w(0) * t(1) - w(1) * t(0);
  v += delta_v;

  // b. transform velocities in IMU frame to lidar frame:
  w = R.transpose() * w;
  v = R.transpose() * v;

  // finally:
  angular_velocity = w;
  linear_velocity = v;
}
}  // namespace localization_common
